/**
  \page cfscffrontpageCFS CFDP (CF) Documentation
  <UL>
     <LI> \subpage cfscfintro
     <LI> \subpage cfscfovr
     <LI> \subpage cfscfovrdsn
     <LI> \subpage cfscfopr
     <LI> \subpage cfscfdg
     <LI> \subpage cfscfcfgpg
     <LI> \subpage cfscftbl
     <LI> \subpage cfscfcmdspg
     <LI> \subpage cfscftlmpg
     <LI> \subpage cfscfeventspg
     <LI> \subpage cfscfcons
     <LI> \subpage cfscffaqs
  </UL>
**/

/**
  \page cfscfintro CFS CFDP Introduction

  <H1> Scope </H1>

  This document provides a design and operational overview along with a complete specification
  for the commands and telemetry associated with the CFS CFDP (CF) application software.

  The document is intended primarily for users of the software (operations personnel, test
  engineers, and maintenance personnel).  The deployment guide section, is intended for mission
  developers when deploying and configuring the CF application software for a mission
  flight software build environment.

  \ref cfscfversion

  <H1> Acronyms </H1>

  <TABLE BORDER="1" CELLPADDING="2" WIDTH="60%">
  <TR><TD WIDTH="20%"> <B>Acronym</B> </TD> <TD WIDTH="40%"> <B>Description</B>                       </TD>
  <TR><TD WIDTH="20%"> API     </TD> <TD WIDTH="40%"> Application Programming Interface               </TD>
  <TR><TD WIDTH="20%"> ATP     </TD> <TD WIDTH="40%"> Absolute Time Processor                         </TD>
  <TR><TD WIDTH="20%"> ATS     </TD> <TD WIDTH="40%"> Absolute Time tagged command Sequence           </TD>
  <TR><TD WIDTH="20%"> CCSDS   </TD> <TD WIDTH="40%"> Consultative Committee for Space Data Systems   </TD>
  <TR><TD WIDTH="20%"> C&DH    </TD> <TD WIDTH="40%"> Command and Data Handling                       </TD>
  <TR><TD WIDTH="20%"> CFE     </TD> <TD WIDTH="40%"> Core Flight Executive                           </TD>
  <TR><TD WIDTH="20%"> CFS     </TD> <TD WIDTH="40%"> Core Flight System                              </TD>
  <TR><TD WIDTH="20%"> CI      </TD> <TD WIDTH="40%"> Command Ingest                                  </TD>
  <TR><TD WIDTH="20%"> Cmd     </TD> <TD WIDTH="40%"> Command                                         </TD>
  <TR><TD WIDTH="20%"> CPU     </TD> <TD WIDTH="40%"> Central Processing Unit                         </TD>
  <TR><TD WIDTH="20%"> EDAC    </TD> <TD WIDTH="40%"> Error Detection and Correction                  </TD>
  <TR><TD WIDTH="20%"> FDS     </TD> <TD WIDTH="40%"> Flight Data System                              </TD>
  <TR><TD WIDTH="20%"> FM      </TD> <TD WIDTH="40%"> File Manager                                    </TD>
  <TR><TD WIDTH="20%"> FSW     </TD> <TD WIDTH="40%"> Flight Software                                 </TD>
  <TR><TD WIDTH="20%"> GN&C    </TD> <TD WIDTH="40%"> Guidance Navigation & Control                   </TD>
  <TR><TD WIDTH="20%"> GSFC    </TD> <TD WIDTH="40%"> Goddard Space Flight Center                     </TD>
  <TR><TD WIDTH="20%"> HK      </TD> <TD WIDTH="40%"> Housekeeping                                    </TD>
  <TR><TD WIDTH="20%"> HW, H/W </TD> <TD WIDTH="40%"> Hardware                                        </TD>
  <TR><TD WIDTH="20%"> ICD     </TD> <TD WIDTH="40%"> Interface Control Document                      </TD>
  <TR><TD WIDTH="20%"> ISR     </TD> <TD WIDTH="40%"> Interrupt Service Routine                       </TD>
  <TR><TD WIDTH="20%"> OS      </TD> <TD WIDTH="40%"> Operating System                                </TD>
  <TR><TD WIDTH="20%"> OSAL    </TD> <TD WIDTH="40%"> Operating System Abstraction Layer              </TD>
  <TR><TD WIDTH="20%"> Pkts    </TD> <TD WIDTH="40%"> Packets                                         </TD>
  <TR><TD WIDTH="20%"> RAM     </TD> <TD WIDTH="40%"> Random-Access Memory                            </TD>
  <TR><TD WIDTH="20%"> RTOS    </TD> <TD WIDTH="40%"> Real Time Operating System                      </TD>
  <TR><TD WIDTH="20%"> RTP     </TD> <TD WIDTH="40%"> Relative Time Processor                         </TD>
  <TR><TD WIDTH="20%"> RTS     </TD> <TD WIDTH="40%"> Relative Time tagged command Sequence           </TD>
  <TR><TD WIDTH="20%"> SB      </TD> <TD WIDTH="40%"> Software Bus Service                            </TD>
  <TR><TD WIDTH="20%"> SBC     </TD> <TD WIDTH="40%"> Single Board Computer                           </TD>
  <TR><TD WIDTH="20%"> SC      </TD> <TD WIDTH="40%"> Stored Commands task                            </TD>
  <TR><TD WIDTH="20%"> SW, S/W </TD> <TD WIDTH="40%"> Software                                        </TD>
  <TR><TD WIDTH="20%"> TBD     </TD> <TD WIDTH="40%"> To Be Determined                                </TD>
  <TR><TD WIDTH="20%"> TBL     </TD> <TD WIDTH="40%"> Table                                           </TD>
  <TR><TD WIDTH="20%"> TLM     </TD> <TD WIDTH="40%"> Telemetry                                       </TD>
  <TR><TD WIDTH="20%"> UTC     </TD> <TD WIDTH="40%"> Universal time code                             </TD>
  </TABLE>

  Prev: \ref cfscffrontpageCFS <BR>
  Next: \ref cfscfovr

**/

/**
  \page cfscfovr CFS CFDP Overview

  CF is a cFS application for providing CFDP (CCSDS File Delivery Protocol) services
  that was designed to interface to the Core Flight Executive (cFE).
  Its primary function is to provide file receive and transmit functionality to this
  protocol. It works by mapping CFDP PDUs on and off cFS's software bus.

  CF is a highly configurable application that is designed to be used on a wide
  range of flight missions. CF obtains its initial configuration through a
  configuration table and its platform and mission configuration files. The
  table contains default configuration settings and is loaded during CF
  initialization. The platform and mission configuration files are compile-time
  configuration parameters.

  To transfer files using CFDP, the CF application must communicate with a CFDP
  compliant peer. CF may be configured to have any number of peers. The ASIST and
  ITOS ground systems contain a compliant peer that may be used for flight to
  ground (and ground to flight) transfers.

  CF sends and receives file information and file-data in Protocol Data Units
  (PDUs) that are compliant with the CFDP standard protocol defined in the CCSDS
  727.0-B-4 Blue Book. The PDUs are transferred to and from the CF application
  via CCSDS packets on the software bus. The system must be configured to get
  the PDU packets from the peer to the software bus (and vice-versa).

  On a typical spacecraft using the cFE, science files and engineering files are
  continuously being created and queued for downlink. When transmission begins,
  the files are converted into a series of PDUs by CF, one after another
  essentially creating a continuous stream of file-data PDUs.

  The CFS CFDP application is a CFDP implementation written specifically for CFS.
  The goal was bounded, small,
  time and space-efficient implementation of the CFDP features necessary for flight.
  CF implements Class 1 and 2 send and receive, as well as logic to cancel, suspend,
  resume, abandon, freeze, etc.  Messages utilize "zero-copy" software bus buffers.
  CF configuration is mainly through the configuration table.

  There are special features listed in the CFDP standard that are not applicable
  to flight software and are therefore not supported by this version of CF. See
  the constraints section of this document for more information.

  Prev: \ref cfscfintro <BR>
  Next: \ref cfscfovrdsn

**/

/**
  \page cfscfovrdsn CFS CFDP Design

  The CF Application has an operational interface consisting of one table, two
  different telemetry messages and twenty commands.

  CF is an event-driven, single-threaded application that wakes up when one of
  the following four messages are received on its software bus pipe. Ground
  command, Housekeeping Request command, Incoming PDU or the Wake-up command.
  The Wake-up command tells CF to do file transaction processing. This command
  is typically sent periodically by the scheduler. The amount of
  file-transaction processing that is executed when this command is received, is
  configurable through the table parameter engine-cycles per wake-up.

  <H2> Key differences from CF v2.X </H2>

  - There's no more text-based ground commands where strings are sent for commands.
  - There's no more memory pool. Everything is set up with limits both in platform
    config for static memory limits and the configuration table for dynamic timing and functionality limits.
  - Much smaller code footprint. CF 3.0 is light-weight flight-only app. It does not provide any ground engine support.

  For simplicity, the examples throughout this document refer to a typical
  operational scenario whereby the peer to the CF application is located on the
  ground. The CF application knows only of incoming file transactions and
  outgoing file transactions. The terms uplink, downlink and playback are
  often used, but only apply when the peer is located on the ground. CF may be
  configured to have more than one peer. One peer may be located onboard the
  spacecraft while another is located on the ground.

  Prev: \ref cfscfovr <BR>
  Next: \ref cfscfopr

**/

/**
  \page cfscfopr CFS CFDP Operation

  <H2> Initialization </H2>

  CF initialization is the same for Power On Resets and Processor Resets.
  Standard application initialization activities are performed such as status and
  tracking initialization, message initialization and subscription, table
  initialization and registering with event services.

  <H2> Outgoing Messages </H2>

  The priority of CF's use of available outgoing messages on each wakeup is:

  -# Send any pending message required for RX transaction
  -# Re-send any message required for TX transaction if timer expired (for example,
     send EOF, or re-send EOF if ACK timer expired)
  -# Send a filedata PDU in response to a NAK request. Per wakeup, one will be sent
     per each transaction in the TX wait state.
  -# Once all TX wait transactions have processed their needs to send, the currently
     active TX transfer will send new filedata PDUs. It will keep sending them until
     there are no more messages on that wakeup (or the throttling semaphore stops it.)

  <H2> Incoming Messages </H2>

   Operationally, the flow of input packets from ground into CF
   should be throttled at some rate appropriate for ingest. CF
   has a per-channel configuration item for max number of RX messages
   processed per wakeup, and both CF and the ingest app
   need to be able to handle this.

  <H2> Temporary file and directory use </H2>

   Currently the temporary directory is only used to store class 2 RX file data
   in temporary files on a transaction that has not yet received a metadata PDU.
   When/if the metadata is received for that transaction, OS_mv is used to transition
   the temporary file to the desired destination location.  Note that OS_mv attempts
   a rename first (faster but does not work across file systems), and if that
   fails then attempts a copy/delete (slower).  Due to this the most efficient
   temporary directory configuration is for it to be on the same file system as the
   destination.  Note that currently this only impacts class 2 RX with an out
   of order metadata packet, but there's future work being considered to
   use the temporary location for all receipts with an atomic transfer of the
   file after successful reception and verification (where applicable) of all the
   file data.

  <H2> Engine </H2>

  The CF application has a single internal core referred to as the engine. The
  engine is capable of transmitting and receiving a configurable number of
  transactions simultaneously. The engine builds outgoing Protocol Data Units
  (PDUs) and interprets the incoming PDUs. It handles all details regarding the
  CFDP standard protocol which is defined in the CCSDS 727.0-B-4 Blue Book. The
  engine processes the file transactions when it is 'cycled'. The number of
  engine cycles per wake up is a configuration parameter defined in the table.
  At most one PDU will be sent on a single engine cycle.
  Typically, the peer node also has an engine. When CF is transferring files to
  and from the ground, the peer is sometimes referred to as the ground engine.
  When faults and timeouts occur, it is important to indicate which engine
  detected the event.

  <H2> Starting a Transaction </H2>

  To transfer a file from the ground to the spacecraft, a 'put' request is given
  to the ground engine. There is no ground command telling CF to 'get' a file.
  The first indication to CF that an uplink transaction has started, is the
  receipt of the first PDU sent by the ground and received by CF.

  To transfer a file from the spacecraft to the ground, a transmit file ground
  command is sent to CF. This ground command translates into a 'put' request to
  the flight engine.

  The CFDP protocol does not support the concept of a 'get' request. The request
  to transfer a file is always made with a 'put' request at the source peer
  (i.e. where the file is located).

  <H2> Transaction Class </H2>

  All transfers are sent and received in one of two modes, class 1 or class 2.
  The CF application is capable of sending and receiving in class 1 and class 2.
  Class 1 transfers are similar to UDP in that they send the data once and
  expect no feedback from the peer. Class 2 transfers are more reliable and
  attempt to fill in data that may have been dropped on the first attempt.
  Class 2 transfers are analogous to TCP.

  <H2> Queue Entries </H2>

  The CF application keeps track of files in queue entries. There is one queue
  entry per transaction. The queue entries contain information such as filename
  and path, priority, class, channel etc. about each transaction. For incoming
  file transactions, the queue entry starts on the incoming active queue and is
  moved to the incoming history queue when the transaction is complete. For
  outgoing transactions, all queue entries start out on the pending queue (in
  response to a playback file command for example). The queue entry is then
  moved to the outgoing active queue when the transaction begins and to the
  history queue when complete.

  <H2> Queues </H2>

  The CF application tracks pending transactions, active transactions and
  completed transactions in its queues. For downlink (or outgoing) transactions
  there are three queues per channel, a pending queue, an active queue and a
  history queue. All queues hold queue entries that are described in the 'Queue
  Entries' section of this document. When a request to downlink a file is
  received, a queue entry is created and placed on the pending queue. When the
  transaction begins, the corresponding queue entry is moved from the pending
  queue to the active queue. After the transaction completes, (whether
  successful or not) the queue entry is moved from the active queue to the
  history queue. The history queue has a fixed depth, defined by the user in the
  CF configuration table. If a transaction is added when the history queue is
  full, the oldest queue entry is deleted.

  For uplink (or incoming) transactions there are two queues, an active queue
  and a history queue. Uplink transactions do not have a pending queue as with
  outgoing transactions. When an uplink transaction begins, a queue entry is
  added to the active queue. When the transaction completes, the queue entry is
  moved from the active queue to the history queue. The history queue depth is
  specified by the user in the CF configuration table. When the history queue is
  full and an active transaction finishes, the oldest entry on the history queue
  is deleted.

  <H2> Incoming File Transactions </H2>

  When files are transferred in the uplink direction, the ground peer receives
  the initial request to send the file. This action causes the ground peer to
  send a series of PDUs that are routed to the CF application. The CF
  application does not get a request to receive a file. The first indication to
  the CF application that an uplink transaction has started, is the receipt of
  the first PDU of the transaction.

  The CF application is capable of receiving files in class 1 or class 2 mode on
  a per-file basis. The class mode is embedded in the PDUs received.

  The message ID for incoming PDUs is defined in the CF configuration table.

  When a file is uploaded to the spacecraft in class 2 mode, the CF app must
  acknowledge the receipt of the file by sending an acknowledgment PDU to the
  ground. This response must be sent on a specified output channel (output
  channels are described later). The channel number for this response is defined
  by the user in the configuration table.

  The CF application keeps a list of all incoming transactions in its internal
  queues. There are two queues designated for incoming transfers. The incoming
  active queue holds information about all incoming transactions that are
  currently active. The incoming history queue holds information about all
  incoming transactions that are complete. The full contents of either queue can
  be viewed on command. The depth of the history queue is defined in the table.

  <H2> Outgoing File Transactions </H2>

  All outgoing file transactions are initiated by the CF application in response
  to a playback file command, a playback directory command or a file found in a
  polling directory. The peer entity does not request to receive a file. All
  outgoing file transactions are inserted into a pending queue by CF before they
  are actually sent. The CF application reads the pending queue (if reading is
  enabled) and starts the next transaction immediately after the data from the
  previous file has been sent. This process of queueing files and sending them
  sequentially, prevents the engine from being inundated when the user requests
  to send multiple files. Once the transactions begins, the queue entry is moved
  to the outgoing active queue and then to the outgoing history queue when it's
  complete. The engine processes the outgoing file transactions when it is
  'cycled'. The number of engine cycles per wake up is defined in the table. At
  most one PDU will be sent on a single engine cycle.

  <H2> Output Channels </H2>

  The CF application supports sending files to a configurable number of
  destinations. The output channels are configured through table parameters.
  Each channel has a pending queue, active queue and history queue.  All queue
  entries for outgoing transactions start out on the pending queue, then get
  moved to the active queue when the transaction begins. After the transaction
  is complete the queue entry is moved to the history queue. The queues may be
  viewed by command at any time. The pending queue reads may be enabled or
  disabled at any time. Each channel has a dedicated throttling semaphore, peer
  entity ID, message ID for outgoing PDUs and a configurable number of polling
  directories. File output transactions may occur simultaneously on different
  channels. The engine processes all active outgoing transactions in a
  round-robin fashion so as not to starve any one transaction. CF is not
  capable of prioritizing across channels.

  <H2> Queueing Files for Output </H2>

  There are three ways to request a file (or files) to be sent. The file
  transmit command, the directory playback command or through poll directory
  processing. The CF polling directory feature continually checks a directory
  for files and after detecting a new file in the directory, inserts a queue
  entry containing the file name (and other info) on the pending queue.

  <H2> Priority </H2>

  Each file-send transaction has an associated priority which is specified by
  the user. The priority of the transaction determines where it is inserted in
  the pending queue. High priority transactions get inserted toward the front of
  the queue. There are 256 levels of priority, zero being the highest. Priority
  is given as a command parameter for the playback file command and the playback
  directory command. For poll directory processing, each polling directory has
  an associated priority given as a table parameter. Please note that this
  priority applies only within a channel. CF does not support prioritization
  across channels. Prioritization across channels (if needed) would typically be
  implemented by the application receiving the PDUs.

  <H2> Preserve Setting </H2>

  When an outgoing file transaction is successfully complete, the user may want
  the file to be deleted by CF. The preserve setting allows the user to specify
  whether the file is deleted or not. The preserve setting gives two choices,
  delete or keep. This setting is specified as a parameter in the transmit file
  command, the playback directory command and on each polling directory. If a
  file transaction is not successful, the file cannot be deleted by CF.

  <H2> Throttling Semaphore </H2>

  Throttling outgoing PDUs may be necessary when the application that receives
  the outgoing PDUs (typically TO) needs to control the flow of packets. The
  throttling semaphore is a counting semaphore that is shared between another
  application and CF. Throttling may be configured as in-use or not-in-use on a
  per-channel basis. To configure as in-use, the receiving app must create a
  counting semaphore during initialization, using the name defined in the CF
  table. After creation, the receiving app must 'give' the semaphore each time
  it is ready to receive a PDU. On the CF side, CF attempts to get the semaphore
  ID by calling an OSAL function to Get-SemaphoreID-by-Name during CF
  initialization. The name defined in the table is given as a parameter to this
  call. CF has code to ensure that this call is executed after the receiving app
  initializes. If the attempt to Get-SemaphoreID-by-Name fails, then throttling
  on that channel is not-in-use and PDUs are sent whenever the engine has a PDU
  ready to output. If successful, each time the engine has a PDU to output, CF
  will attempt a non-blocking 'take' on the throttling semaphore. If the 'take'
  is successful, the green light counter in telemetry is incremented and the PDU
  is sent on the software bus. If the 'take' is not successful, the PDU is held
  by the engine, the red-light counter is incremented and the 'take' is called
  again on the next engine cycle.

  <H2> Polling Directories </H2>

  A polling directory is a directory that is polled by CF periodically. CF does
  not create these directories. They must be created before they can be enabled.
  When files are found in a polling directory that is enabled, the files are
  automatically queued by CF for output. The polling rate is configurable and
  each channel has a configurable number of polling directories.  Each polling
  directory has an enable, a class setting, a priority setting, a preserve
  setting and a destination directory. When enabled, CF will periodically check
  the polling directories for files. When a file is found, CF will place the
  file information on the pending queue if it is closed and not already on the
  queue and not currently active. All polling directories are checked at the
  same frequency which is defined by the table parameter
  NumWakeupsPerPollDirChk. Setting this parameter to one will cause CF to check
  the polling directories at the fastest possible rate, every time it receives a
  'wake-up' command. Checking polling directories is a processor-intensive
  effort, it is best to keep the polling rate as low as possible.

  <H2> Efficiency </H2>

  The CF application can be a processor intensive application.  Some operating
  systems have significant overhead associated with file system operations.
  Opening and closing a file, querying the file system for file size, deleting
  the file, opening directories, looping through a directory list can consume a
  considerable amount of processor time. For this reason, transmitting small
  files at a high rate for long periods of time may be a worst-case-timing
  scenario. File system overhead is less of an issue when file sizes are large.
  The terms 'large' and 'small' used here are relative to the downlink rate.
  With a downlink rate of 1 Mbps for example, a good file size would be 1 MByte
  or larger.

  Also, it is best to keep the number of files on the pending queue to a
  minimum. When the number of files on the pending queue is high, (such as
  hundreds) prioritization and standard checking causes CF processing to be
  significant each time a file is added to the queue.

  Polling directory processing is also subject to file system overhead.  It is
  recommended that the rate of poll processing be kept low and unused polling
  directories should be disabled.

  <H2> Memory Use </H2>

  CF uses statically allocated memory based on configuration parameters defined
  in the platform configuration file. This static memory is used for queue entries.
  The life cycle of a queue entry begins when a request to queue a file for downlink
  is received. Or in the case of incoming transactions, the queue entry is reserved
  when the meta-data PDU is received by CF. For the incoming transaction case, the
  queue entry starts out on the incoming active queue, then the entry is moved to
  the history queue when the transaction completes. For outgoing transactions, the
  queue entry starts out on the pending queue, then moves to the active queue when
  the transaction begins, then moves to the history queue when the transaction is
  complete.

  The history queue has a sliding window effect. When the queue is full and a
  new transaction needs to be added, the oldest transaction will be removed,
  making room for the new transaction.

  The history queue depth is a configuration parameter and specified in the CF
  configuration table. When the queue entry is 'pushed-off' the history queue,
  the memory for the queue will be available.

  For incoming file transactions, CF uses a statically allocated buffer for the
  incoming PDU. The size of this buffer is defined by the platform configuration
  parameter, CF_MAX_PDU_SIZE. The incoming PDU's are copied from the Software Bus
  into this buffer and then passed to the engine.

  For outgoing file transactions, the engine uses a statically allocated buffer for
  PDUs. The size of this buffer is defined by platform configuration parameter,
  CF_MAX_PDU_SIZE. The engine informs the CF app when it has a PDU
  ready to go out. In response to this, the CF app checks with the downlink app
  (e.g. TO) to see if it is ready to receive a PDU. This is done by the CF app
  trying to 'take' the throttling semaphore defined in the CF configuration
  table. If the CF app successfully 'takes' the semaphore, it gives a green
  light to the engine and the PDU is then released by the engine and sent to the
  software bus via the zero-copy delivery mode. There is a green light counter
  and a red light counter for each output channel in telemetry.

  Prev: \ref cfscfovrdsn <BR>
  Next: \ref cfscfdg
**/

/**
  \page cfscfdg CFS CFDP Deployment Guide

  Follow the general guidelines below for platform deployment of the CFDP app.

  <H2> Configuration </H2>
  CF uses two sets of configuration parameters: compile-time configurable parameters
  in the cf_platform_cfg.h file and run-time configurable parameters in the cf_def_config.c
  file.  Most parameters are included in the cf_def_config.c file for maximum flexibility.

  cf_platform_cfg.h uses macro definitions for configurable options, while cf_def_config.c
  uses a table. cf_def_config.c parameters can be accessed using the get/set functions
  CF_CmdGetParam() and CF_CmdSetParam().

  CF expects to receive a CF_WAKEUP_MID message from the SCH (scheduler) app at a fixed
  rate. The number of wakeups per second is reflected in the configuration table. This
  drives CF's timing.

  <H3> Channels </H3>

  CF version 3.0 has a concept of "channels" which have their own configuration. The
  channel configuration is done in the cf_def_config.c file and allows message IDs for
  incoming and outgoing PDUs to be unique per channel. Each channel can be configured with
  polling directories as well.

  <H3> Flow Control </H3>

  By default, CF assumes that a per-channel semaphore is provided by the Telemetry Output
  (TO) application or an equivalent application.  The semaphore name is defined in the
  CF configuration table and must match the name of the semaphore created by TO. If
  TO does not create a semaphore, the semaphore name can be left as an empty string
  in the configuration table indicating that a semaphore should not be used.  If a
  semaphore is expected and not found, the application will terminate during
  initialization.  If no semaphore is used, the outgoing messages per wakeup may
  need to be more limited. It's a valid configuration to have both the semaphore and maximum
  outgoing messages per wakeup as well.

  <H2> Integration </H2>

  <H3> Software Bus </H3>

  Each channel has an input message ID that is subscribed on, and a message ID to publish its messages on.

  <H3> Scheduler </H3>

  CF as a whole expects the CF_WAKEUP_MID message as described earlier at a fixed rate.
  If the number of wakeups per second is changed in SCH, then the ticks_per_second
  configuration parameter in the CF configuration table must also be updated.

  <H3> Endianness </H3>

  CF is endian agnostic and no longer requires specific compile time configuration/defines
  to handle different endian systems.

  <H3> Integration with TO </H3>

  TO's pipe needs to be able to receive packets of #CF_MAX_PDU_SIZE

  Prev: \ref cfscfopr <BR>
  Next: \ref cfscfcfgpg

**/

/**
 * \page cfscfcfgpg CFS CFDP Configuration

  The CF application provides the user with a set of compile-time configuration
  parameters as well as a set of run-time configuration parameters. All
  compile-time configuration parameters are specified in headers files. There
  are three header files used by the CF application, cf_platform_cfg.h,
  cf_perfids.h and cf_msgids.h. For details regarding the compile-time
  configuration parameters, refer to the header files.

 * \ref cfscfmissioncfg
 *
 * \ref cfscfplatformcfg

  All run-time configuration parameters are specified in the CF configuration
  table.

 * \ref cfscftbl

  Prev: \ref cfscfdg <BR>
  Next: \ref cfscfcmdspg

 */

/**
 * \page cfscfcmdspg CFS CFDP Commands
 *
 * \subpage cfscfcmddesc
 *
 * \ref cfscfcmdmid
 *
 * \ref cfscfcmdstructs
 *
 * \ref cfscfcmdcodes

  Prev: \ref cfscftbl <BR>
  Next: \ref cfscftlmpg

 */

/**
  \page cfscfcmddesc CFS CFDP Command Descriptions

  <H2> Noop Command </H2>

  The CF Noop command is sent to CF using message ID #CF_CMD_MID with command
  code #CF_NOOP_CC. This command is useful for verifying that the command
  interface to the CF Application is working. It also causes an event message
  to be generated that contains the CF Application's version information.
  It should be noted that the version information can also be obtained when the
  Application starts up. After CF has successfully initialized itself, an event
  message is generated that indicates successful initialization and also includes the
  Application's version information.  Both of these event messages are
  'Informational' and are NOT filtered by default.


  <H2> Reset Counters Command </H2>

  The CF Reset counters command is sent to CF using message ID #CF_CMD_MID with
  command code #CF_RESET_CC. This command is used to reset the counters in the
  housekeeping telemetry packet. All counters can be reset or they can be reset
  by category. The categories are command counters, fault counters, incoming
  file counters and outgoing file counters.

  When the command is executed successfully, the command counter will be zero
  and an event message will be generated.

  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.

  \verbatim
     *  \par Command Structure
     *       #CF_UnionArgs_Payload_t where byte[0] specifies the counters type, byte[1-3] don't care:
     *       - 0 = all counters
     *       - 1 = command counters
     *       - 2 = fault counters
     *       - 3 = up counters
     *       - 4 = down counters
     typedef union CF_UnionArgs_Payload
     {
         uint32 dword;    
         uint16 hword[2]; 
         uint8  byte[4];  
     }
CF_UnionArgs_Payload_t;
\endverbatim

    The command parameter byte[0] identifies which category of counters to
        reset.counters. The value should be set to one of five possible values defined in the reset enumeration.

  \verbatim typedef enum {
            CF_Reset_all     = 0, 
            CF_Reset_command = 1, 
            CF_Reset_fault   = 2, 
            CF_Reset_up      = 3, 
            CF_Reset_down    = 4  
        } CF_Reset_t;
  \endverbatim



  <H2> Transmit File Command </H2>
    
  The CF Transmit File command is sent to CF using message ID #CF_CMD_MID with
  command code #CF_TX_FILE_CC.
  
  This command is used to queue a file to be sent by the CF application. To
  'transmit' a file means to output, or send a file.
  
  When the command is executed successfully, the command counter will increment
  and an event will be generated.
  
  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.

  \verbatim
  typedef struct CF_TxFileCmd
  {
      CFE_MSG_CommandHeader_t cmd_header;                        
      uint8                   cfdp_class;                        
      uint8                   keep;                              
      uint8                   chan_num;                          
      uint8                   priority;                          
      CF_EntityId_t           dest_id;                           
      char                    src_filename[CF_FILENAME_MAX_LEN]; 
      char                    dst_filename[CF_FILENAME_MAX_LEN]; 
  } CF_TxFileCmd_t;
  \endverbatim
  
  The first parameter, \c cfdp_class, identifies whether the file will be transferred
  using #CF_CFDP_CLASS_1 or #CF_CFDP_CLASS_2. For Class 1 transfers, CF will send the data
  once and expect no feedback from the peer. Class 2 transfers are more reliable
  and attempt to fill in data that may have been dropped on the first attempt.

  The second parameter, \c keep, specifies whether the file will be deleted
  or preserved by CF after the transfer successfully completes. To have the file
  deleted by CF, set this parameter to zero. If this parameter is set to one,
  the file will not be deleted. Regardless of the setting, if the file-transfer
  is not successful the file will not be deleted. 
  
  The third parameter, \c chan_num, specifies the output channel in which the
  file will be sent. The value range for this parameter is 0 to
  (#CF_NUM_CHANNELS - 1). #CF_NUM_CHANNELS is specified in the
  CF platform configuration file.
    
  The fourth parameter, \c priority, specifies where the file is placed on the
  pending queue. High priority files are placed at the front of the queue. A 
  value of zero is the highest priority. A value of 255 is the lowest priority.
    
  The fifth parameter, \c src_filename, specifies the path name and filename to
  send. This parameter is a string with max size equal to #CF_FILENAME_MAX_LEN
  bytes. The src_filename must be an existing file. The string must begin
  with a forward slash, have no spaces and be properly terminated.
  
  The last parameter, \c dst_filename, specifies the destination path name and
  filename. This parameter is a string with max size equal to #CF_FILENAME_MAX_LEN
  bytes. This parameter is delivered to the peer so that the peer knows
  where to store the file. The peer engine dictates the requirements of this
  string. The CF application allows this string to be NULL in which case the
  peer engine will store the incoming file in the default directory. If the
  string is not NULL, CF requires that it is properly terminated and contains no
  spaces. This parameter can be used to rename the file after it's received at
  the destination.
  
  
  
  <H2> Playback Directory Command </H2>
  
  The CF Playback Directory command is sent to CF using message ID #CF_CMD_MID
  with command code #CF_PLAYBACK_DIR_CC.  The command causes an event message
  to be generated. This command is used to queue the files that are located
  in the specified directory at the time the command is received.
  
  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.
  
  To 'playback' a directory means to send all files in that directory. To queue
  the files for sending, the class must be 1 or 2, the channel must be in-use,
  the files must be closed and not be active or pending, the preserve parameter
  must be 0 (Delete) or 1 (Keep), the path names must include no spaces and be
  properly terminated. The src_filename must begin and end with a forward slash. All
  possible values for Priority are valid. A priority value of zero is the
  highest priority.
      
  \verbatim
  typedef CF_TxFileCmd_t CF_PlaybackDirCmd_t;
  typedef struct CF_TxFileCmd
  {
      CFE_MSG_CommandHeader_t cmd_header;                        
      uint8                   cfdp_class;                        
      uint8                   keep;                              
      uint8                   chan_num;                          
      uint8                   priority;                          
      CF_EntityId_t           dest_id;                           
      char                    src_filename[CF_FILENAME_MAX_LEN]; 
      char                    dst_filename[CF_FILENAME_MAX_LEN]; 
  } CF_TxFileCmd_t;
  \endverbatim
    
  The first parameter, \c cfdp_class, identifies whether the files will be
  transferred using #CF_CFDP_CLASS_1 or #CF_CFDP_CLASS_2. For Class 1 transfers, CF will
  send the data once and expect no feedback from the peer. Class 2 transfers are
  more reliable and attempt to fill in data that may have been dropped on the
  first attempt.

  The second parameter, \c keep, specifies whether the files will be deleted
  or preserved by CF after the transfer successfully completes. To have the
  files deleted by CF, set this parameter to zero. If this parameter is set to
  one, the file will not be deleted. Regardless of the setting, if the
  file-transfer is not successful the file will not be deleted. 

  The third parameter, \c chan_num, specifies the output channel in which the files
  will be sent. All files in the directory will be sent on the specified
  channel. The value range for this parameter is 0 to (#CF_NUM_CHANNELS
  - 1). #CF_NUM_CHANNELS is specified in the CF platform configuration
  file.
  
  The fourth parameter, \c priority, specifies where the files are placed on the
  pending queue. All files in the directory will be queued with the given
  priority. High priority files are placed at the front of the queue. A value of
  zero is the highest priority. A value of 255 is the lowest priority.
    
  The fifth parameter, \c src_filename, specifies the path name where the files are
  located. The string must have no spaces, be properly terminated and have a
  forward slash as the last character. This parameter is a string with max size
  equal to #CF_FILENAME_MAX_LEN characters.
  
  The last parameter, \c dst_filename, specifies where the files are to be stored
  after they are received by the peer. This parameter is a string with max size
  equal to #CF_FILENAME_MAX_LEN bytes. This parameter is delivered to the peer so
  that the peer knows where to store the file. The peer engine dictates the requirements
  of this string. The CF application allows this string to be NULL in which case the
  peer engine will store the incoming files in the default directory. If the string 
  is not NULL, CF requires that it is properly terminated, contains no spaces and ends
  with a forward slash. There is no way to rename the files at the destination as in 
  the Playback File command.

  
  <H2> Freeze Command </H2>
  
  The CF Freeze command is sent to CF using message ID #CF_CMD_MID with command
  code #CF_FREEZE_CC. The freeze command has no command parameters. This command
  is used to freeze all transactions. The freeze command should be applied to
  both the source and destination peers at nearly the same time. 
  
  When the command is executed successfully, the command counter is incremented
  and an event message will be generated. This event message is an
  'Informational' type and is NOT filtered by default. If the command is not successful,
  the command error counter will increment and an error event will be generated
  indicating the reason for failure.
   
 
  <H2> Thaw Command </H2>
  
  The CF Thaw command is sent to CF using message ID #CF_CMD_MID with command
  code #CF_THAW_CC. The thaw command has no command parameters. This command is
  used to thaw all transactions that were commanded to 'freeze' earlier. The
  thaw command should be applied to both the source and destination peers at
  nearly the same time.
  
  When the command is executed successfully, the command counter is incremented
  and an event message will be generated. This event message is an
  'Informational' type and is NOT filtered by default. If the command is not successful,
  the command error counter will increment and an error event will be generated
  indicating the reason for failure.

  
  <H2> Suspend Command </H2>
  
  The CF Suspend command is sent to CF using message ID #CF_CMD_MID with command
  code #CF_SUSPEND_CC. This command is used to suspend one or all transactions.
  The suspend command has one command parameter that indicates what transaction
  to suspend. See details below.  The suspend command should be applied to both
  the source and destination peers at nearly the same time.  
  
  When the command is executed successfully, the command counter is incremented
  and an event message will be generated. This event message is an
  'Informational' type and is NOT filtered by default. If the command is not successful,
  the command error counter will increment and an error event will be generated
  indicating the reason for failure.
  
  NOTE: Suspending an outgoing transaction before EOF is sent, will pause the
  flow of PDUs on that channel. This happens because the next file is started
  when the current file EOF is sent. If a user wishes to stop the current transaction
  (before the EOF is sent) and still allow the next pending file to begin, the
  current transaction should be cancelled (or abandoned) in lieu of being
  suspended. Canceling is always a better option than abandoning. 
  
  NOTE: When a suspended transaction is cancelled, the cancel does not take 
  effect until the transaction is resumed.

  \verbatim 
  typedef struct CF_TransactionCmd
  {
      CFE_MSG_CommandHeader_t cmd_header; 
      CF_TransactionSeq_t     ts;         
      CF_EntityId_t           eid;        
      uint8                   chan;       
      uint8                   spare[3];   
  } CF_TransactionCmd_t;

  \endverbatim

  The \c ts parameter specifies the transaction sequence number to suspend.
  The \c eid parameter specifies the entity id used in the transaction.
  The \c chan parameter can specify a single channel, all channels, or the channel
  corresponding to the transaction sequence number.  
    
  
  <H2> Resume Command </H2>
  
  The CF Resume command is sent to CF using message ID #CF_CMD_MID with command
  code #CF_RESUME_CC. This command is used to resume a suspended transaction or
  all transactions. The resume command has one command parameter that indicates
  what transaction to resume. See details below.  The resume command should be
  applied to both the source and destination peers at nearly the same time.
  
  When the command is executed successfully, the command counter is incremented
  and an event message will be generated. This event message is an
  'Informational' type and is NOT filtered by default. If the command is not successful,
  the command error counter will increment and an error event will be generated
  indicating the reason for failure.

  \verbatim 
  typedef struct CF_TransactionCmd
  {
      CFE_MSG_CommandHeader_t cmd_header; 
      CF_TransactionSeq_t     ts;         
      CF_EntityId_t           eid;        
      uint8                   chan;       
      uint8                   spare[3];   
  } CF_TransactionCmd_t;

  \endverbatim

  The \c ts parameter specifies the transaction sequence number to resume.
  The \c eid parameter specifies the entity id used in the transaction.
  The \c chan parameter can specify a single channel, all channels, or the channel
  corresponding to the transaction sequence number.  
    
  
  <H2> Cancel Command </H2>

  The CF Cancel command is sent to CF using message ID #CF_CMD_MID with command
  code #CF_CANCEL_CC. This command is used to cancel a transaction or all
  transactions. The cancel command has one command parameter that indicates what
  transaction to cancel. See details below.  The cancel command should be sent
  to the source entity only. For example, uplink transactions should be
  cancelled at the ground engine. The CF application should not receive a cancel
  command in this case. The CF application will learn of the cancel request
  through the protocol messages. Downlink transactions and outgoing transactions 
  (with respect to CF)  should be cancelled by sending this CF cancel command.

  When the command is executed successfully, the command counter is incremented
  and an event message will be generated. This event message is an
  'Informational' type and is NOT filtered by default. If the command is not successful,
  the command error counter will increment and an error event will be generated
  indicating the reason for failure.
  
  NOTE: If a Cancel command is received by CF on an outgoing transaction that 
  is suspended, the cancel does not take effect until the transaction is 
  resumed.  


  \verbatim 
  typedef struct CF_TransactionCmd
  {
      CFE_MSG_CommandHeader_t cmd_header; 
      CF_TransactionSeq_t     ts;         
      CF_EntityId_t           eid;        
      uint8                   chan;       
      uint8                   spare[3];   
  } CF_TransactionCmd_t;

  \endverbatim

  The \c ts parameter specifies the transaction sequence number to cancel.
  The \c eid parameter specifies the entity id used in the transaction.
  The \c chan parameter can specify a single channel, all channels, or the channel
  corresponding to the transaction sequence number.  

  
  <H2> Abandon Command </H2>
  
  The CF Abandon command is sent to CF using message ID #CF_CMD_MID with command
  code #CF_ABANDON_CC. This command is used to abandon a transaction or all
  transactions. The abandon command has one command parameter that indicates
  what transaction to abandon. See details below.  The abandon command should be
  applied to both the source and destination peers at nearly the same time. 

  When the command is executed successfully, the command counter is incremented
  and an event message will be generated. This event message is an 'Informational' 
  type and is NOT filtered by default.
  
  If the command is not successful, the command error counter will increment and 
  an error event will be generated indicating the reason for failure.
  When the command is executed successfully, the command counter is incremented
  and an event message will be generated. This event message is an
  'Informational' type and is NOT filtered by default. If the command is not successful,
  the command error counter will increment and an error event will be generated
  indicating the reason for failure.
  
  NOTE: Unlike the cancel command, if a suspended transaction is abandoned, the
  transaction will be abandoned at the time the abandon command is received.
  Likewise, if a frozen transaction is abandoned, the transaction will be
  abandoned when the abandoned cmd is received.
    
  \verbatim 
  typedef struct CF_TransactionCmd
  {
      CFE_MSG_CommandHeader_t cmd_header; 
      CF_TransactionSeq_t     ts;         
      CF_EntityId_t           eid;        
      uint8                   chan;       
      uint8                   spare[3];   
  } CF_TransactionCmd_t;

  \endverbatim

  The \c ts parameter specifies the transaction sequence number to abandon.
  The \c eid parameter specifies the entity id used in the transaction.
  The \c chan parameter can specify a single channel, all channels, or the channel
  corresponding to the transaction sequence number.  
  
  
  
  <H2> Set MIB Parameter Command </H2>
  
  The CF Set MIB Parameter command is sent to CF using message ID #CF_CMD_MID
  with command code #CF_SET_MIB_PARAM_CC. This command is used to change the
  flight engine Message Information Base (MIB). The MIB is a term used in the
  CCSDS blue book that can be interpreted as the engine configuration
  parameters. The command has two command parameters, Param indicates which
  parameter to change, and Value indicates the new setting. 
  
  When the command is executed successfully, the command counter is incremented
  and an event message will be generated displaying the parameter values received. 
  This event message is an 'Informational' type and is NOT filtered by default.
  
  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.
    
  This command may be used to change any flight MIB parameter.
  
  NOTE: Changing these parameters will change the actual table values, thereby 
  changing the checksum of the CF configuration table.
      
  \verbatim 
  typedef struct CF_SetParamCmd
  {
      CFE_MSG_CommandHeader_t cmd_header; 
      uint32                  value;      
      uint8                   key;        
      uint8                   chan_num;   
      uint8                   spare[2];   
  } CF_SetParamCmd_t;

  \endverbatim

  The \c value parameter specifies the new value of the engine
  parameter.
    
  The \c key parameter specifies which engine parameter to set.
  
  The \c chan_num parameter specifies the channel number to set.
    
  
  <H2> Get MIB Parameter Command </H2>
  
  The CF Set MIB Parameter command is sent to CF using message ID #CF_CMD_MID
  with command code #CF_GET_MIB_PARAM_CC. This command is used to view a single
  Message Information Base (MIB) parameter. The MIB is a term used in the CCSDS
  blue book that can be interpreted as the engine configuration parameters. 
    
  The command has two command parameter, key indicates which parameter to
  view and the channel number specifies the channel configuration to use.
  The parameter given and its current setting will be displayed in the event.
  
  When the command is executed successfully, the command counter is incremented
  and an event message will be generated displaying the given parameter value 
  and the current setting for that parameter. This event message is an 'Informational' 
  type and is NOT filtered by default. 
  
  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.
      
  This command may be used to view any flight MIB parameter.  
     
  \verbatim 
  typedef struct CF_GetParamCmd
  {
      CFE_MSG_CommandHeader_t cmd_header; 
      uint8                   key;        
      uint8                   chan_num;   
  } CF_GetParamCmd_t;

  \endverbatim
    
  The \c key parameter specifies which engine parameter to get.
  
  The \c chan_num parameter specifies the channel number to get the data from.
    
    
  <H2> Write Queue Information Command </H2>
  

  The CF Write Queue Information command is sent to CF using message ID
#CF_CMD_MID with command code #CF_WRITE_QUEUE_CC.  
  
  This command is used to write the contents of a single queue to a file. CF has
  a pending, queue, an active queue and a history queue for each output channel.
  CF also has an active queue and a history queue for incoming transactions.

  When the command is executed successfully, the command counter is incremented
  and an event message will be generated.

  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.  
    
  \verbatim
  typedef struct CF_WriteQueueCmd
  {
      CFE_MSG_CommandHeader_t cmd_header; 
      uint8                   type;       
      uint8                   chan;       
      uint8                   queue;      
      uint8                   spare;      

      char filename[CF_FILENAME_MAX_LEN]; 
  } CF_WriteQueueCmd_t;

  \endverbatim
  
  The first parameter, \c type, specifies the queue type. The queue type may be 
  uplink (incoming), or downlink (outgoing), or both,

  The second parameter, \c chan, is necessary only if the type parameter is set
  to a value of two (downlink). If the Type parameter is set to a value of one
  (uplink), the code does not read this parameter. Chan specifies the downlink 
  channel that owns the queue. The value range for this parameter is 0 to 
  (#CF_NUM_CHANNELS - 1). #CF_NUM_CHANNELS is specified in the 
  CF platform configuration file.
  
  The third parameter, \c queue, identifies which queue contents will be written 
  to the file. A value of 0 for pending queue, 1 for active and 2 for history.  
  Because there is no uplink pending queue, a value of zero is not valid when 
  the Type parameter is set to one (uplink). 

  The fourth parameter, \c filename, specifies the name of the file that will
  receive the queue data. This parameter is a string with max size equal to
#CF_FILENAME_MAX_LEN bytes specified in the CF platform configuration file.

  
  <H2> Enable Dequeue Command </H2>
  
  The CF Enable Dequeue command is sent to CF using message ID #CF_CMD_MID with
  command code #CF_ENABLE_DEQUEUE_CC. 
  
  This command is used to enable reading from the pending queue on a particular
  channel. It has one parameter (channel) and is sent when the pending queue
  reads are disabled for that channel. The pending queue holds the names of the
  files that are waiting to be sent out by CF. This command has no effect on
  incoming file transactions.

  When the command is executed successfully, the command counter is incremented
  and an event message will be generated.

  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.  
  
  \verbatim
       *       Command Structure
       *       #CF_UnionArgs_Payload_t where byte[0] specifies the channel number or all channels
       *       - 255 = all channels
       *       - else = single channel  
       typedef union CF_UnionArgs_Payload
  {
      uint32 dword;    
      uint16 hword[2]; 
      uint8  byte[4];  
  } CF_UnionArgs_Payload_t;
  \endverbatim  

  The first and only parameter, \c byte[0], specifies which pending queue to enable.
  Each channel has one pending queue. The value range for this parameter is 0 to 
  255. A value of 255 specifies all channels. All other values are for a single channel.


  <H2> Disable Dequeue Command </H2>
 
  The CF Enable Dequeue command is sent to CF using message ID #CF_CMD_MID with
  command code #CF_DISABLE_DEQUEUE_CC. 
  
  This command is used to disable reading from the pending queue on a particular
  channel. It has one parameter (channel) and sent when the user would like to 
  stop sending files on a particular channel. 
  
  NOTE: This command does not stop a file transaction that is in progress on the 
  specified channel. Use the cancel command to stop a file transaction that is 
  in progress.
  

  When the command is executed successfully, the command counter is incremented
  and then an event message will be generated.

  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.  
  
  \verbatim
       *       Command Structure
       *       #CF_UnionArgs_Payload_t where byte[0] specifies the channel number or all channels
       *       - 255 = all channels
       *       - else = single channel  

       typedef union CF_UnionArgs_Payload
  {
      uint32 dword;    
      uint16 hword[2]; 
      uint8  byte[4];  
  } CF_UnionArgs_Payload_t;
  \endverbatim  

  The first and only parameter, \c byte[0], specifies which pending queue to enable.
  Each channel has one pending queue. The value range for this parameter is 0 to 
  255. A value of 255 specifies all channels. All other values are for a single channel.


  <H2> Enable Directory Polling Command </H2>
  
  The CF Enable Directory Polling command is sent to CF using message ID
#CF_CMD_MID with command code #CF_ENABLE_DIR_POLLING_CC. 
  
  This command is used to enable one or all polling directories on a particular
  channel. CF will check polling directories for filenames and queue them for
  output, only if the polling directory is enabled. Polling directory processing
  consumes a fair amount of CPU utilization. Opening directories periodically
  and looping through hidden files, closed files and files that have already
  been queued can take a substantial amount of CPU time. It is recommended to
  keep polling directories disabled when they are not actively receiving files.
  
  When the command is executed successfully, the command counter is incremented
  and an event message will be generated.  

  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.  
  
  \verbatim
     *       Command Structure
     *       #CF_UnionArgs_Payload_t
     *
     *       byte[0] specifies the channel number or all channels
     *       - 255 = all channels
     *       - else = single channel
     *
     *       byte[1] specifies the polling directory index
     *       - 255 = all polling directories
     *       - else = single polling directory index
     *

     typedef union CF_UnionArgs_Payload
  {
      uint32 dword;    
      uint16 hword[2]; 
      uint8  byte[4];  
  } CF_UnionArgs_Payload_t;
  \endverbatim  

  The first parameter, \c byte[0], specifies which channel contains the polling 
  directory to enable. The value range for this parameter is 0 to 255. A value 
  of 255 specifies all channels. All other values are for a single channel.
  
  The second parameter, \c byte[1], specifies which polling directory to enable. To
  enable all polling directories on a specific channel, set this parameter to
  0xFF. The polling directories are numbered from zero to
  (CF_MAX_POLLING_DIRS_PER_CHAN - 1). CF_MAX_POLLING_DIRS_PER_CHAN is specified
  in the CF platform configuration file. The polling directory number may be obtained
  by viewing the contents of the CF configuration table.  
  

  <H2> Disable Directory Polling Command </H2>
  
  The CF Enable Directory Polling command is sent to CF using message ID
#CF_CMD_MID with command code #CF_DISABLE_DIR_POLLING_CC. 
  
  This command is used to disable one or all polling directories on a particular
  channel. CF will check polling directories for filenames and queue them for
  output, only if the polling directory is enabled. Polling directory processing
  consumes a fair amount of CPU utilization. Opening directories periodically
  and looping through hidden files, closed files and files that have already
  been queued can take a substantial amount of CPU time. It is recommended to
  keep polling directories disabled when they are not actively receiving files.
  
  When the command is executed successfully, the command counter is incremented
  and an event message will be generated.

  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.  
  
  \verbatim
     *       Command Structure
     *       #CF_UnionArgs_Payload_t
     *
     *       byte[0] specifies the channel number or all channels
     *       - 255 = all channels
     *       - else = single channel
     *
     *       byte[1] specifies the polling directory index
     *       - 255 = all polling directories
     *       - else = single polling directory index
     *

     typedef union CF_UnionArgs_Payload
  {
      uint32 dword;    
      uint16 hword[2]; 
      uint8  byte[4];  
  } CF_UnionArgs_Payload_t;
  \endverbatim  

  The first parameter, \c byte[0], specifies which channel contains the polling 
  directory to disable. The value range for this parameter is 0 to 255. A value 
  of 255 specifies all channels. All other values are for a single channel.
  
  The second parameter, \c byte[1], specifies which polling directory to disable. To
  disable all polling directories on a specific channel, set this parameter to
  0xFF. The polling directories are numbered from zero to
  (CF_MAX_POLLING_DIRS_PER_CHAN - 1). CF_MAX_POLLING_DIRS_PER_CHAN is specified
  in the CF platform configuration file. The polling directory number may be obtained
  by viewing the contents of the CF configuration table.  


  <H2> Purge Queue Command </H2>
  
  The CF Write Queue Information command is sent to CF using message ID
#CF_CMD_MID with command code #CF_PURGE_QUEUE_CC.  
  
  This command is used to remove all entries on a single queue. CF has a
  pending queue, an active queue, and a history queue for each channel.
  Only the pending and history queues can be purged.

  When the command is executed successfully, the command counter is incremented
  and an event message will be generated indicating that the node has been removed.

  If the command is not successful, the command error counter will increment and
  an error event will be generated indicating the reason for failure.  

  \verbatim
     *       Command Structure
     *       #CF_UnionArgs_Payload_t
     *
     *       byte[0] specifies the channel number or all channels
     *       - 255 = all channels
     *       - else = single channel
     *
     *       byte[1] specifies the queue
     *       - 0 = Pending queue
     *       - 1 = History queue
     *       - 2 = Both pending and history queue
     *

     typedef union CF_UnionArgs_Payload
  {
      uint32 dword;    
      uint16 hword[2]; 
      uint8  byte[4];  
  } CF_UnionArgs_Payload_t;
  \endverbatim  

  The first parameter, \c byte[0], specifies a single channel id or a value
  indicating all channels.
      
  The second parameter, \c byte[1], identifies which queue will be purged. 
  A value of 0 for pending queue, 1 for history and 2 for both.  
 
  <H2> Enable Engine Command </H2>
  
  The CF Enable Engine command is sent to CF using message ID
#CF_CMD_MID with command code #CF_ENABLE_ENGINE_CC. The command has no
  command parameters and is used to reinitialize engine and enable processing.  
  Note configuration table updates are not processed while the engine is enabled.


  <H2> Enable Disable Command </H2>
  
  The CF Enable Engine command is sent to CF using message ID
#CF_CMD_MID with command code #CF_DISABLE_ENGINE_CC. The command has no
  command parameters and is used to disable engine processing.  
  Note configuration table updates can be performed while the engine is disabled, 
  and when the engine is re-enabled the new configuration will take effect.
  
  Prev: \ref cfscfcfgpg <BR>
  Next: \ref cfscftlmpg
**/

/**
 * \page cfscftlmpg CFS CFDP Telemetry
 *
 * \subpage cfscftlmdesc
 *
 * \ref cfscftlmmid
 *
 * \ref cfscftlm
 *
 
  Prev: \ref cfscfcmdspg <BR>
  Next: \ref cfscfeventspg
 */

/**
  \page cfscftlmdesc CFS CFDP Telemetry Descriptions
  
  <H2> CF Housekeeping Telemetry Packet </H2>
  
  The Housekeeping Telemetry packet is sent by CF to the software bus on
  command. When CF receives the CF_SEND_HK_MID command, a packet is constructed
  and sent by CF. CF typically receives this command every four or five seconds.
  
  
  <H2> CF End of Transaction Packet </H2>
  
  The End of Transaction packet is sent to the software bus upon completion 
  of a file send or receive transaction. A packet with message ID #CF_EOT_TLM_MID is
  constructed and sent by CF. The packet contains information about the last
  completed transaction which includes sequence number, channel, direction, state,
  status, EID, file size, CRC result, and filenames.
    
  Prev: \ref cfscftlmpg <BR>
  Next: \ref cfscftbl
**/



/**
 * \page cfscfeventspg CFS CFDP Events
 *
 * \ref cfscfevents
 *
  Prev: \ref cfscftlmpg <BR>
  Next: \ref cfscfcons
 */


/**
  \page cfscftbl CFS CFDP Table Definitions

  The CF application has one table used for configuration. This table is
  accessed during initialization and updated by CF when changes to the table
  parameters are made through CF commands or CFE table services. 
  
  The table contains default configuration settings. Many table configuration
  settings can be adjusted by command. These adjustments will modify the table
  and are therefore reflected if the table is dumped. These adjustments will
  also change the table checksum. The configuration table is loaded at the time
  the application is started. CF supports table updates during runtime only when
  the engine is disabled.
      
  CF utilizes a CFS table for run-time configuration defined by #CF_ConfigTable_t.  The channel
  configuration is in #CF_ConfigTable_t.chan which contains a polling element defined by
  #CF_PollDir_t.

  Prev: \ref cfscfcfgpg <BR>
  Next: \ref cfscfcons

**/

/**
  \page cfscfcons CFS CFDP Constraints

  CF is currently limited by the Software Bus performance.  Future work may
  include implementing a point-to-point interface for high speed transfers.

  The CFDP standard CCSDS 727.0-B-4 allows a variety of data-type sizes for
  Source and Destination Entity ID's, Transaction ID and PDU Header length.
  Currently, this application does not support the following:
  1. an Entity ID length other than the size defined in cf_platform_cfg.h
  2. a transaction ID length other than the size defined in cf_platform_cfg.h
  3. a PDU header size greater than CF_CFDP_MAX_HEADER_SIZE bytes 

  The stack size for the CF application must be monitored and must be no less
  than 16384 bytes. Depending on the CF configuration, the stack size may need
  to be set higher than 16384. The stack size is specified in the cfe_es_startup.scr
  file that is located in the /mission/build/xxx/exe area.
  
  Poll directories must not have subdirectories, otherwise errors will occur
  at put request time.

  All files in polling directories must be closed. 

  The same file cannot be sent on two channels at same time. 

  Spaces are not allowed in filenames.

  Segmentation control as described in the blue book is not supported by this
  version of CFS CF application. All outgoing transactions will have the
  segmentation control bit in the meta-data PDU set to - 'Recorded Boundaries
  Not Respected'.
  
  This version of CF does not support keep alive procedures that are detailed in
  section 4.1.6.5 of CFDP CCSDS 727.0-B-4 Blue Book.
  
  Invalid file structures are not supported by this version of the CF
  application. Invalid file structures are described in 4.1.6.1.1.8 of CFDP
  CCSDS 727.0-B-4 Blue Book and apply only when record boundaries are respected
  (see segmentation control above).

  Only transmission modes unacknowledged (class 1) and acknowledged (class 2) are
  supported by the CF application.
  
  The CFDP Application will fail on startup if the following conditions are not met:
  
  <UL>
    <LI> Unable to create a Software Bus Pipe  <BR>
    <LI> Unable to subscribe to the CF Command Message  <BR>
    <LI> Unable to subscribe to the CF Housekeeping Request Message  <BR>
    <LI> Unable to register for cFE Event Services  <BR>
    <LI> Unable to register the CF Configuration Table with cFE Table Services  <BR>
    <LI> Unable to load the CF Configuration Table with a defaut table file  <BR>
    <LI> Unable to acquire a pointer to the CF Configuration Table  <BR>
  </UL>
  
  Each one of these conditions will generate a unique event message and will cause the CF
  Application to terminate before processing any CF command pipe messages.
  
  Prev: \ref cfscfeventspg <BR>
  Next: \ref cfscffaqs

**/

/**
  \page cfscffaqs CFS CFDP Frequently Asked Questions

  No CF specific FAQ's have been identified/documented.
**/
